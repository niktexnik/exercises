# frozen_string_literal :true

def connect_hashes(hash1, hash2)
  summ_of_hash1 = hash1.inject(0){ |sum, (_k, v)| sum + v.to_i }
  summ_of_hash2 = hash2.inject(0){ |sum, (_k, v)| sum + v.to_i }

  united_hash = hash1.merge(hash2) do |_k, sum1, sum2|
    summ_of_hash1 <= summ_of_hash2 ? sum2 : sum1
  end
  united_hash.delete_if { |_k, v| v < 10 }.sort_by { |_k, v| v }.to_h
end
# Упражнение 9
# Необходимо разработать метод connect_hashes(hash1, hash2), который соединит два переданных хеша, значениями ключей в которых являются числа, и вернет
# новый хэш, полученный по следующим правилам:
# • приоритетными являются ключи того хэша, сумма значений ключей, которого больше (если суммы значений ключей будут равны,то второй хэш считается более приоритетнее)
# • ключи со значениями меньше 10 не должны попасть в финальный хэш
# • получившийся хэш должен вернуться упорядоченным по значениям ключей в порядке возрастания.
# Тесты для примеров и проверки:
p connect_hashes({ a: 2, b: 12 }, { c: 11, e: 5 }) # => { c: 11, b: 12 }
p connect_hashes({ a: 13, b: 9, d: 11 }, { c: 12, a: 15 }) # => { d: 11, c:12, a: 13 }
p connect_hashes({ a: 14, b: 12 }, { c: 11, a: 15 }) # => { c: 11, b: 12, a:15 }